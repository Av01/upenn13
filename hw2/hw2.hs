{-# OPTIONS_GHC -Wall #-}
module Hw2.LogAnalysis where

import Hw2.Log
import Text.Read
--Exercise 1 The first step is figuring out how to parse an individual
--message. Define a function
--parseMessage :: String -> LogMessage
--which parses an individual line from the log file. For example,
--parseMessage "E 2 562 help help"
-- == LogMessage (Error 2) 562 "help help"
--parseMessage "I 29 la la la"
-- == LogMessage Info 29 "la la la"
--parseMessage "This is not in the right format"
-- == Unknown "This is not in the right format"
--Once we can parse one log message, we can parse a whole log file.
--Define a function
--parse :: String -> [LogMessage]
--which parses an entire log file at once and returns its contents as a
--list of LogMessages.
--To test your function, use the testParse function provided in the
--Log module, giving it as arguments your parse function, the number
--of lines to parse, and the log file to parse from (which should also be
--in the same folder as your assignment). For example, after loading
--your assignment into GHCi, type something like this at the prompt:
--testParse parse 10 "error.log"
--Don’t reinvent the wheel! (That’s so last week.) Use Prelude functions to make your solution as concise, high-level, and functional as
--possible. For example, to convert a String like "562" into an Int, you
--can use the read function. Other functions which may (or may not)
--be useful to you include lines, words, unwords, take, drop, and (.).
--Putting the logs in order
--Unfortunately, due to the error messages being generated by multiple
--servers in multiple locations around the globe, a lightning storm, a
--failed disk, and a bored yet incompetent programmer, the log messages are horribly out of order. Until we do some organizing, there
--will be no way to make sense of what went wrong! We’ve designed a
--data structure that should help—a binary search tree of LogMessages:
--data MessageTree = Leaf
-- | Node MessageTree LogMessage MessageTree
--Note that MessageTree is a recursive data type: the Node constructor itself takes two children as arguments, representing the left and
--right subtrees, as well as a LogMessage. Here, Leaf represents the
--empty tree.
--A MessageTree should be sorted by timestamp: that is, the timestamp of a LogMessage in any Node should be greater than all timestamps of any LogMessage in the left subtree, and less than all timestamps of any LogMessage in the right child.
--Unknown messages should not be stored in a MessageTree since
--they lack a timestamp.

--Attempt one
--parseMessage :: String -> LogMessage
--parseMessage s
--   | ws1 == "I" = LogMessage Info (read ws2::Int) (merge 2 wordList)
--   | ws1 == "W" = LogMessage Warning (read ws2::Int) (merge 2 wordList)
--   | ws1 == "E" = LogMessage (Error (read ws2::Int)) (read ws3::Int) (merge 3 wordList)
--   | otherwise = Unknown s
--       where wordList = words s
--             ws1 = wordList !! 0
--             ws2 = wordList !! 1
--             ws3 = wordList !! 2

--merge :: Int -> [String] -> String
--merge k xs = tail $ foldr (\x y-> " " ++ x ++ y) "" (drop k xs)
-- can also use merge k xs = unwords (drop k xs)

parseMessage :: String -> LogMessage
parseMessage str = case (parseVals (words str)) of
                    (Just logType,Just t,msg) -> (LogMessage logType t msg)
                    _ -> Unknown str


parseVals :: [String] -> (Maybe MessageType, Maybe TimeStamp, String)
parseVals ("I":t:rest) = (Just Info, (readMaybe t)::(Maybe Int), unwords rest)
parseVals ("W":t:rest) = (Just Warning, (readMaybe t)::(Maybe Int), unwords rest)
parseVals ("E":i:t:rest) = (checkError i, (readMaybe t)::(Maybe Int), unwords rest)
parseVals _ = (Nothing, Nothing, "")


checkError :: String -> Maybe MessageType
checkError i = case ((readMaybe i)::(Maybe Int)) of
    Just v -> Just (Error v)
    _ -> Nothing

parse :: String -> [LogMessage]
parse contents =  map parseMessage (lines contents)

--Exercise 2 Define a function
--insert :: LogMessage -> MessageTree -> MessageTree
--which inserts a new LogMessage into an existing MessageTree, producing a new MessageTree. insert may assume that it is given a
--sorted MessageTree, and must produce a new sorted MessageTree
--containing the new LogMessage in addition to the contents of the
--original MessageTree.
--However, note that if insert is given a LogMessage which is
--Unknown, it should return the MessageTree unchanged.

insert :: LogMessage -> MessageTree -> MessageTree
insert (Unknown _) msgTree = msgTree
insert v@(LogMessage _ t _) (Node lchild v'@(LogMessage _ t' _) rchild) = if t < t'
                                                                       then (Node (insert v lchild) v' rchild)
                                                                       else (Node lchild v' (insert v rchild))
insert v _ = Node Leaf v Leaf

--Exercise 3 Once we can insert a single LogMessage into a MessageTree,
--we can build a complete MessageTree from a list of messages. Specifically, define a function
--build :: [LogMessage] -> MessageTree
--which builds up a MessageTree containing the messages in the list,
--by successively inserting the messages into a MessageTree (beginning
--with a Leaf).

build :: [LogMessage] -> MessageTree
build = foldr insert Leaf


--Exercise 4 Finally, define the function
--inOrder :: MessageTree -> [LogMessage]
--which takes a sorted MessageTree and produces a list of all the
--LogMessages it contains, sorted by timestamp from smallest to biggest.
-- (This is known as an in-order traversal of the MessageTree.)
--With these functions, we can now remove Unknown messages and
--sort the well-formed messages using an expression such as:
--inOrder (build tree)
-- [Note: there are much better ways to sort a list; this is just an exercise to get you working with recursive data structures!]
--Log file postmortem


inOrder :: MessageTree -> [LogMessage]
inOrder Leaf = []
inOrder (Node lchild v rchild) = (inOrder lchild) ++ (v:(inOrder rchild))



--Exercise 5 Now that we can sort the log messages, the only thing
--left to do is extract the relevant information. We have decided that
--“relevant” means “errors with a severity of at least 50”.
--Write a function
--whatWentWrong :: [LogMessage] -> [String]
--which takes an unsorted list of LogMessages, and returns a list of the
--messages corresponding to any errors with a severity of 50 or greater,
--sorted by timestamp. (Of course, you can use your functions from the
--previous exercises to do the sorting.)
--For example, suppose our log file looked like this:
--I 6 Completed armadillo processing
--I 1 Nothing to report
--E 99 10 Flange failed!
--I 4 Everything normal
--I 11 Initiating self-destruct sequence
--E 70 3 Way too many pickles
--E 65 8 Bad pickle-flange interaction detected
--W 5 Flange is due for a check-up
--I 7 Out for lunch, back in two time steps
--E 20 2 Too many pickles
--I 9 Back from lunch
--This file is provided as sample.log. There are four errors, three of
--which have a severity of greater than 50. The output of whatWentWrong
--on sample.log ought to be
--[ "Way too many pickles"
--, "Bad pickle-flange interaction detected"
--, "Flange failed!"
--]
--You can test your whatWentWrong function with testWhatWentWrong,
--which is also provided by the Log module. You should provide
--testWhatWentWrong with your parse function, your whatWentWrong
--function, and the name of the log file to parse.

whatWentWrong :: [LogMessage] -> [String]
whatWentWrong xs = getMessages $ filter relevant (inOrder $ build xs)

relevant :: LogMessage -> Bool
relevant (LogMessage (Error i) _ _) = i >= 50
relevant _ = False

getMessage :: LogMessage -> String
getMessage (LogMessage _ _ msg) = msg
getMessage (Unknown msg) = msg

getMessages :: [LogMessage] -> [String]
getMessages xs = map getMessage xs
